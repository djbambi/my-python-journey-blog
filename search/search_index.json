{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to My Python Journey Blog","text":"<p>Welcome to my blog where I document my journey learning Python and software development.</p>"},{"location":"#latest-posts","title":"Latest Posts","text":"<p>Check out the Blog for the latest posts and updates.</p>"},{"location":"#about-this-site","title":"About This Site","text":"<p>This site is built with Material for MkDocs and documents my learning experiences, code examples, and insights as I develop my Python skills.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/#subscribe","title":"\ud83d\udcec Subscribe","text":"<p>If you\u2019d like to follow new posts without relying on social media or algorithms:</p> <p>\ud83d\udd17 Raw RSS feed</p>"},{"location":"blog/2026/02/07/adding-resilience-with-tenacity--retry-logic-for-http-requests/","title":"Adding Resilience with Tenacity: Retry Logic for HTTP Requests","text":"<p>After building a simple, testable weather API client, the next logical step was making it resilient to transient failures.</p> <p>Network requests fail. Servers time out. APIs rate-limit. These aren't bugs\u2014they're expected conditions that production code needs to handle gracefully.</p> <p>This post explains how I added retry logic with exponential backoff using the <code>tenacity</code> library, and what I learned about designing fault-tolerant systems.</p>","tags":["pybites","pdm","tenacity","resilience"]},{"location":"blog/2026/02/07/adding-resilience-with-tenacity--retry-logic-for-http-requests/#the-problem-network-requests-are-unreliable","title":"The problem: network requests are unreliable","text":"<p>My initial <code>api_call()</code> function was simple:</p> <pre><code>def api_call(session, url, params=None, timeout_s=3.0):\n    response = session.get(url, params=params, timeout=timeout_s)\n    response.raise_for_status()\n    return response\n</code></pre> <p>This works perfectly\u2014until it doesn't.</p> <p>What happens when: - The network hiccups? - The API returns a 503 \"Service Unavailable\"? - The server is temporarily overloaded?</p> <p>The function would fail immediately, even though retrying a second later might succeed.</p>","tags":["pybites","pdm","tenacity","resilience"]},{"location":"blog/2026/02/07/adding-resilience-with-tenacity--retry-logic-for-http-requests/#why-not-just-wrap-it-in-a-loop","title":"Why not just wrap it in a loop?","text":"<p>I could have written manual retry logic:</p> <pre><code>for attempt in range(3):\n    try:\n        return session.get(...)\n    except Exception:\n        if attempt == 2:\n            raise\n        time.sleep(2 ** attempt)  # exponential backoff\n</code></pre> <p>But this approach has problems: - Logic mixed with behaviour (retry config embedded in code) - Hard to test (retry timing is hardcoded) - Not reusable (every function needs its own retry loop) - Error-prone (easy to get backoff math wrong)</p> <p>Instead, I used <code>tenacity</code>\u2014a library designed specifically for this.</p>","tags":["pybites","pdm","tenacity","resilience"]},{"location":"blog/2026/02/07/adding-resilience-with-tenacity--retry-logic-for-http-requests/#introducing-tenacity","title":"Introducing tenacity","text":"<p><code>tenacity</code> is a Python library that provides declarative retry logic through decorators.</p> <p>The key insight: retries are a cross-cutting concern, not part of your core logic.</p> <p>Instead of embedding retry logic inside your function, you declare it outside:</p> <pre><code>from tenacity import retry, stop_after_attempt\n\n@retry(stop=stop_after_attempt(3))\ndef api_call(session, url, params=None, timeout_s=3.0):\n    response = session.get(url, params=params, timeout=timeout_s)\n    response.raise_for_status()\n    return response\n</code></pre> <p>The function code stays clean. The retry behaviour is explicit and separate.</p>","tags":["pybites","pdm","tenacity","resilience"]},{"location":"blog/2026/02/07/adding-resilience-with-tenacity--retry-logic-for-http-requests/#making-retry-configuration-explicit","title":"Making retry configuration explicit","text":"<p>I didn't want retry settings hardcoded in the decorator. They should live in configuration, just like API keys and timeouts.</p> <p>I extended my <code>Settings</code> class:</p> <pre><code>class Settings(BaseSettings):\n    # ...existing fields...\n    retry_initial_wait_seconds: int = Field(default=1)\n    max_retry_attempts: int = Field(default=3, ge=0, le=10)\n    retry_backoff_multiplier: float = Field(default=2.0, gt=0)\n    retry_max_wait_seconds: int = Field(default=60, gt=0)\n</code></pre> <p>Now retry behaviour is: - Validated (attempts must be between 0-10) - Documented (clear defaults and constraints) - Configurable (can be changed via environment variables)</p>","tags":["pybites","pdm","tenacity","resilience"]},{"location":"blog/2026/02/07/adding-resilience-with-tenacity--retry-logic-for-http-requests/#implementing-exponential-backoff-with-jitter","title":"Implementing exponential backoff with jitter","text":"<p>Simple retries can cause thundering herd problems\u2014if 1000 clients all retry at the same time, they create another spike of load.</p> <p>The solution: exponential backoff with jitter.</p> <pre><code>from tenacity import wait_exponential_jitter\n\n@retry(\n    stop=stop_after_attempt(settings.max_retry_attempts),\n    wait=wait_exponential_jitter(\n        initial=settings.retry_initial_wait_seconds,\n        max=settings.retry_max_wait_seconds,\n        exp_base=settings.retry_backoff_multiplier,\n    ),\n    reraise=True,\n)\ndef api_call(...):\n    ...\n</code></pre> <p>This means: - First retry: wait ~1 second (+ random jitter) - Second retry: wait ~2 seconds (+ jitter) - Third retry: wait ~4 seconds (+ jitter) - Max wait: capped at 60 seconds</p> <p>The jitter spreads out retry attempts, preventing synchronized retry storms.</p>","tags":["pybites","pdm","tenacity","resilience"]},{"location":"blog/2026/02/07/adding-resilience-with-tenacity--retry-logic-for-http-requests/#only-retrying-retriable-errors","title":"Only retrying retriable errors","text":"<p>Not all errors should trigger retries.</p> <p>If I send a <code>401 Unauthorized</code>, retrying won't help\u2014my API key is wrong. But a <code>503 Service Unavailable</code> is temporary.</p> <p>I created a decision function:</p> <pre><code>def _should_retry(exception: BaseException) -&gt; bool:\n    \"\"\"Determine if an exception should trigger a retry.\"\"\"\n    # Always retry network issues\n    if isinstance(exception, (requests.Timeout, requests.ConnectionError)):\n        return True\n\n    # Only retry specific HTTP error codes\n    if isinstance(exception, requests.HTTPError):\n        if exception.response is not None:\n            return exception.response.status_code in {408, 429, 500, 502, 503, 504}\n\n    return False\n</code></pre> <p>This distinguishes between: - Transient failures (retry): timeouts, rate limits, server errors - Permanent failures (don't retry): authentication errors, not found, bad requests</p>","tags":["pybites","pdm","tenacity","resilience"]},{"location":"blog/2026/02/07/adding-resilience-with-tenacity--retry-logic-for-http-requests/#adding-observability-with-logging","title":"Adding observability with logging","text":"<p>When retries happen in production, I want to know about it.</p> <p><code>tenacity</code> provides callbacks for retry events:</p> <pre><code>from tenacity import before_sleep_log, after_log\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@retry(\n    # ...retry config...\n    before_sleep=before_sleep_log(logger, logging.WARNING),\n    after=after_log(logger, logging.INFO),\n    reraise=True,\n)\ndef api_call(...):\n    ...\n</code></pre> <p>Now when a retry happens: - Before sleeping: log at WARNING level (something failed) - After retry: log at INFO level (retry completed) - On final failure: the original exception is re-raised</p> <p>This gives me visibility without cluttering my function code.</p>","tags":["pybites","pdm","tenacity","resilience"]},{"location":"blog/2026/02/07/adding-resilience-with-tenacity--retry-logic-for-http-requests/#the-complete-implementation","title":"The complete implementation","text":"<p>Here's the final <code>api_call()</code> function:</p> <pre><code>@retry(\n    stop=stop_after_attempt(settings.max_retry_attempts),\n    wait=wait_exponential_jitter(\n        initial=settings.retry_initial_wait_seconds,\n        max=settings.retry_max_wait_seconds,\n        exp_base=settings.retry_backoff_multiplier,\n    ),\n    retry=retry_if_exception(_should_retry),\n    before_sleep=before_sleep_log(logger, logging.WARNING),\n    after=after_log(logger, logging.INFO),\n    reraise=True,\n)\ndef api_call(\n    session: Session,\n    url: str,\n    params: dict[str, str | int | float] | None = None,\n    timeout_s: float = 3.0,\n) -&gt; Response:\n    \"\"\"Make an HTTP GET request with retry logic.\"\"\"\n    response = session.get(url, params=params, timeout=timeout_s)\n    response.raise_for_status()\n    return response\n</code></pre> <p>The core logic is unchanged\u2014three lines of code.</p> <p>All the retry behaviour is declarative and separate.</p>","tags":["pybites","pdm","tenacity","resilience"]},{"location":"blog/2026/02/07/adding-resilience-with-tenacity--retry-logic-for-http-requests/#what-i-learned","title":"What I learned","text":"<p>Adding retry logic taught me several important lessons:</p>","tags":["pybites","pdm","tenacity","resilience"]},{"location":"blog/2026/02/07/adding-resilience-with-tenacity--retry-logic-for-http-requests/#1-resilience-is-a-design-concern-not-an-afterthought","title":"1. Resilience is a design concern, not an afterthought","text":"<p>Retries shouldn't be bolted on later\u2014they should be part of your architecture from the start.</p>","tags":["pybites","pdm","tenacity","resilience"]},{"location":"blog/2026/02/07/adding-resilience-with-tenacity--retry-logic-for-http-requests/#2-declarative-is-better-than-imperative","title":"2. Declarative is better than imperative","text":"<p>Using decorators kept retry logic separate from business logic, making both easier to understand.</p>","tags":["pybites","pdm","tenacity","resilience"]},{"location":"blog/2026/02/07/adding-resilience-with-tenacity--retry-logic-for-http-requests/#3-configuration-belongs-in-configuration","title":"3. Configuration belongs in configuration","text":"<p>Retry settings are just as important as API keys\u2014they should be validated, documented, and configurable.</p>","tags":["pybites","pdm","tenacity","resilience"]},{"location":"blog/2026/02/07/adding-resilience-with-tenacity--retry-logic-for-http-requests/#4-not-all-failures-are-equal","title":"4. Not all failures are equal","text":"<p>Distinguishing between retriable and non-retriable errors prevents wasted retries and makes debugging easier.</p>","tags":["pybites","pdm","tenacity","resilience"]},{"location":"blog/2026/02/07/adding-resilience-with-tenacity--retry-logic-for-http-requests/#5-observability-matters","title":"5. Observability matters","text":"<p>Logging retry attempts gives you visibility into system health without requiring manual investigation.</p>","tags":["pybites","pdm","tenacity","resilience"]},{"location":"blog/2026/02/07/adding-resilience-with-tenacity--retry-logic-for-http-requests/#comparing-approaches","title":"Comparing approaches","text":"Approach Pros Cons Manual retry loop Full control, no dependencies Error-prone, hard to test, not reusable <code>tenacity</code> decorator Clean, declarative, well-tested Additional dependency Built-in <code>urllib3</code> retries No extra library Limited to specific HTTP libraries <p>For my use case, <code>tenacity</code> was the clear winner\u2014it separated concerns cleanly and made retry behaviour explicit and configurable.</p>","tags":["pybites","pdm","tenacity","resilience"]},{"location":"blog/2026/02/07/adding-resilience-with-tenacity--retry-logic-for-http-requests/#whats-next","title":"What's next","text":"<p>The retry logic is now solid, but there are still improvements to consider:</p> <ul> <li>Circuit breaker pattern: stop retrying if the service is consistently down</li> <li>Metrics collection: track retry rates and success rates</li> <li>Adaptive backoff: adjust retry timing based on API response headers</li> </ul> <p>But those can wait.</p> <p>For now, I have a resilient, observable HTTP client\u2014and that was the goal.</p>","tags":["pybites","pdm","tenacity","resilience"]},{"location":"blog/2026/02/07/adding-resilience-with-tenacity--retry-logic-for-http-requests/#key-takeaways","title":"Key takeaways","text":"<ul> <li>Use libraries like <code>tenacity</code> for retry logic\u2014don't roll your own</li> <li>Make retry configuration explicit and validated</li> <li>Use exponential backoff with jitter to prevent thundering herds</li> <li>Only retry errors that are actually retriable</li> <li>Add logging to make retry behaviour observable</li> <li>Keep retry logic separate from business logic</li> </ul> <p>Even simple API clients benefit from thoughtful resilience design.</p>","tags":["pybites","pdm","tenacity","resilience"]},{"location":"blog/2026/01/11/starting-the-pybites-pdm--from-can-code-to-can-build/","title":"Designing a Simple, Testable Weather API Client in Python","text":"<p>When I started building a small Python client to fetch data from the OpenWeather API, my goal wasn\u2019t to build a full pipeline or production system. It was to understand the design decisions that make Python code easier to reason about, test, and evolve.</p> <p>This post walks through my thought process and the key choices I made while implementing a simple weather client.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/11/starting-the-pybites-pdm--from-can-code-to-can-build/#the-problem-i-was-solving","title":"The problem I was solving","text":"<p>At its core, the task was simple:</p> <ul> <li>Call an HTTP API  </li> <li>Handle success and failure correctly  </li> <li>Return parsed JSON data  </li> </ul> <p>However, even simple problems can turn messy quickly if responsibilities aren\u2019t clear. I wanted to avoid:</p> <ul> <li>hard-coded configuration  </li> <li>tightly coupled code  </li> <li>untestable HTTP logic  </li> </ul> <p>So I treated this as a design exercise, not just a coding task.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/11/starting-the-pybites-pdm--from-can-code-to-can-build/#separating-configuration-from-behaviour","title":"Separating configuration from behaviour","text":"<p>One of the first decisions I made was to separate configuration from code logic.</p> <p>Things like:</p> <ul> <li>API keys  </li> <li>base URLs  </li> <li>timeouts  </li> </ul> <p>are not behaviour \u2014 they\u2019re environment-specific configuration. Embedding them directly in the client would make the code harder to reuse and harder to test.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/11/starting-the-pybites-pdm--from-can-code-to-can-build/#using-a-dedicated-config-module","title":"Using a dedicated config module","text":"<p>I created a <code>config.py</code> file responsible solely for configuration:</p> <pre><code>class Settings(BaseSettings):\n    openweather_api_key: str\n    openweather_timeout_s: float = 10.0\n    openweather_base_url: HttpUrl = \"https://api.openweathermap.org/data/3.0/onecall/timemachine\"\n</code></pre> <p>This immediately gave me:</p> <ul> <li>a single source of truth for config  </li> <li>clear documentation of required vs optional settings  </li> <li>fast failure if configuration is invalid  </li> </ul>","tags":["pybites","pdm"]},{"location":"blog/2026/01/11/starting-the-pybites-pdm--from-can-code-to-can-build/#why-i-used-pydantic-for-configuration","title":"Why I used Pydantic for configuration","text":"<p>Rather than reading environment variables manually with <code>os.environ</code>, I used Pydantic Settings.</p> <p>This was a deliberate choice.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/11/starting-the-pybites-pdm--from-can-code-to-can-build/#benefits-i-gained-immediately","title":"Benefits I gained immediately","text":"<ul> <li>Validation at startup (e.g. timeout must be &gt; 0)  </li> <li>Type safety (URLs must be valid URLs)  </li> <li>Cleaner code (no scattered <code>os.environ</code> lookups)  </li> <li>Clear failure modes (misconfiguration fails fast)  </li> </ul> <p>This pushed configuration errors to the edges of the system, where they belong.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/11/starting-the-pybites-pdm--from-can-code-to-can-build/#designing-the-weather-client-around-behaviour","title":"Designing the weather client around behaviour","text":"<p>The actual weather client function is intentionally small:</p> <pre><code>def fetch_openweather_data(*, session, url, params, timeout_s):\n    response = session.get(url, params=params, timeout=timeout_s)\n    response.raise_for_status()\n    return response.json()\n</code></pre> <p>This function does exactly three things:</p> <ol> <li>makes a request  </li> <li>fails if the HTTP status is bad  </li> <li>returns parsed JSON  </li> </ol> <p>No configuration. No retries. No orchestration.</p> <p>Just behaviour.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/11/starting-the-pybites-pdm--from-can-code-to-can-build/#dependency-injection-passing-in-the-session","title":"Dependency injection: passing in the session","text":"<p>One of the most important decisions I made was not to create the HTTP session inside the client.</p> <p>Instead, I inject it:</p> <pre><code>fetch_openweather_data(session=session, ...)\n</code></pre>","tags":["pybites","pdm"]},{"location":"blog/2026/01/11/starting-the-pybites-pdm--from-can-code-to-can-build/#why-this-matters","title":"Why this matters","text":"<p>By injecting the session:</p> <ul> <li>the client has no hidden dependencies </li> <li>HTTP configuration (headers, adapters, retries) lives elsewhere  </li> <li>the function is easy to test in isolation  </li> </ul> <p>The client doesn\u2019t care where the session came from \u2014 only that it behaves like one.</p> <p>This follows a simple rule:</p> <p>Functions should depend on what they need, not where it comes from.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/11/starting-the-pybites-pdm--from-can-code-to-can-build/#how-this-enables-easy-testing","title":"How this enables easy testing","text":"<p>Because the session is injected, I can test the client without making real HTTP calls.</p> <p>In tests, I pass in a mock session that:</p> <ul> <li>pretends to have a <code>.get()</code> method  </li> <li>returns a fake response object  </li> <li>simulates success or failure  </li> </ul> <p>This allowed me to test:</p> <ul> <li>success paths  </li> <li>error propagation  </li> <li>correct wiring of arguments  </li> </ul> <p>All without touching the network.</p> <p>The design made testing straightforward \u2014 not something I had to \u201cfight\u201d.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/11/starting-the-pybites-pdm--from-can-code-to-can-build/#freezing-the-scope-at-an-mvp","title":"Freezing the scope at an MVP","text":"<p>During development, it became obvious how quickly this could grow:</p> <ul> <li>retries with backoff  </li> <li>multiple locations and dates  </li> <li>partitioned storage  </li> <li>orchestration via Airflow  </li> </ul> <p>All valid ideas \u2014 but not necessary yet.</p> <p>I deliberately froze the scope at a minimum viable client so I could:</p> <ul> <li>reason clearly about the code  </li> <li>validate design choices through testing  </li> <li>avoid premature abstraction  </li> </ul> <p>This checkpoint now gives me a solid foundation to build on later.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/11/starting-the-pybites-pdm--from-can-code-to-can-build/#key-takeaways","title":"Key takeaways","text":"<p>What this small exercise reinforced for me:</p> <ul> <li>Configuration is not behaviour \u2014 keep it separate  </li> <li>Validate configuration early and explicitly  </li> <li>Inject dependencies to keep code testable  </li> <li>Small, focused functions are easier to reason about  </li> <li>Stopping early is a design decision, not a failure  </li> </ul> <p>Even a simple API client benefits from thoughtful structure.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/11/starting-the-pybites-pdm--from-can-code-to-can-build/#whats-next","title":"What\u2019s next","text":"<p>The next steps (when needed) are clear and incremental:</p> <ul> <li>add retries with exponential backoff  </li> <li>extract parameter-building logic  </li> <li>integrate orchestration  </li> </ul> <p>But those decisions can wait.</p> <p>For now, I have a clean, testable core \u2014 and that was the real goal.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/20/docker-deepish-dive/","title":"Docker Deep(ish) Dive","text":"<p>I recently did a Docker course on Udemy, but the real learning didn\u2019t come from watching videos \u2014 it came from building, breaking, and rebuilding things myself.</p> <p>What I thought Docker was and what it actually is turned out to be subtly but importantly different.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/20/docker-deepish-dive/#containers-are-not-mini-computers","title":"Containers are not mini computers","text":"<p>The biggest mental shift for me was realising that a Docker container is not a lightweight VM.</p> <p>A container: - does not have its own kernel - does not boot an operating system - is just one or more Linux processes, isolated by the kernel</p> <p>On Linux, those processes run directly on the host kernel. On macOS and Windows, Docker Desktop quietly runs a single Linux VM, and all containers run as Linux processes inside that VM. The VM isn\u2019t the point \u2014 it\u2019s just there because macOS and Windows don\u2019t have a Linux kernel.</p> <p>That distinction matters.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/20/docker-deepish-dive/#images-provide-user-space-not-an-os","title":"Images provide user-space, not an OS","text":"<p>When you write:</p> <pre><code>FROM python:3.12-slim\n</code></pre> <p>you\u2019re not getting an operating system \u2014 you\u2019re getting: - a Linux user-space filesystem - a Python binary - shared libraries Python depends on</p> <p>The kernel always comes from the host (or the Docker Desktop VM). Containers share it.</p> <p>That\u2019s why containers start instantly and why you can run hundreds of them without \u201cbooting\u201d anything.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/20/docker-deepish-dive/#containers-have-a-filesystem-but-its-disposable","title":"Containers have a filesystem \u2014 but it\u2019s disposable","text":"<p>A container has a filesystem view built from: - read-only image layers - a thin writable layer on top</p> <p>That writable layer disappears when the container is removed.</p> <p>This explains a lot: - why logs \u201cvanish\u201d when a container exits - why batch jobs don\u2019t hang around - why inspecting container filesystems is usually the wrong approach</p> <p>If you care about data, you mount volumes.</p> <p>Once I started mounting <code>data/</code> and <code>logs/</code> from the host, Docker stopped feeling mysterious and started feeling mechanical \u2014 in a good way.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/20/docker-deepish-dive/#docker-exec-is-not-ssh","title":"<code>docker exec</code> is not SSH","text":"<p>Another subtle but important insight: <code>docker exec</code> doesn\u2019t connect over the network. It just asks the kernel to start another process inside the same container namespaces.</p> <p>That\u2019s why it\u2019s instant, and why it only works when the container is running.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/20/docker-deepish-dive/#dockerfiles-vs-docker-compose","title":"Dockerfiles vs docker-compose","text":"<p>The distinction finally clicked:</p> <ul> <li> <p>Dockerfile: What is this thing?   (base image, dependencies, code, default command)</p> </li> <li> <p>docker-compose: How does it run?   (env vars, volumes, ports, multiple containers)</p> </li> </ul> <p>Once I separated \u201cbuild\u201d from \u201crun\u201d, things stopped getting tangled.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/20/docker-deepish-dive/#why-this-is-such-a-cool-technology","title":"Why this is such a cool technology","text":"<p>Docker feels powerful not because it\u2019s magical, but because it\u2019s honest: - processes, not machines - explicit filesystem access - disposable by default - reproducible by design</p> <p>It forces good habits \u2014 especially around stateless execution and externalised data \u2014 and once you internalise the model, a lot of modern infrastructure suddenly makes sense.</p> <p>I went in expecting \u201ccontainers\u201d. I came out understanding processes, kernels, filesystems, and isolation a bit better.</p> <p>That\u2019s a pretty good trade.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/10/starting-the-pybites-pdm--from-can-code-to-can-build/","title":"Starting the PyBites PDM \u2013 from \u201ccan code\u201d to \u201ccan build\u201d","text":"<p>I\u2019ve started the PyBites Professional Developer Mindset (PDM) program, and it already feels like the right kind of discomfort.</p> <p>Not the \u201cI don\u2019t understand Python at all\u201d kind of discomfort \u2014 but the subtler, more interesting one:</p> <p>realising there are gaps between writing Python that works and writing Python that holds up in production.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/10/starting-the-pybites-pdm--from-can-code-to-can-build/#why-i-signed-up","title":"Why I signed up","text":"<p>I can write Python. I\u2019ve done it professionally.</p> <p>I\u2019ve built pipelines, Lambdas, Glue jobs, and scripts that solve real problems. I can usually get things working, debug issues when they arise, and ship solutions that deliver value.</p> <p>But I kept noticing something.</p> <ul> <li>I could get things working</li> <li>I could debug issues</li> <li>I could ship solutions</li> </ul> <p>Yet when I read really good Python \u2014 the kind that\u2019s calm, intentional, and obvious \u2014 I felt a gap.</p> <p>Not a knowledge gap exactly. More a mindset gap.</p> <p>That\u2019s what drew me to PDM.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/10/starting-the-pybites-pdm--from-can-code-to-can-build/#what-developer-mindset-actually-means-so-far","title":"What \u201cdeveloper mindset\u201d actually means (so far)","text":"<p>Very early on, one thing became clear: this isn\u2019t about learning new syntax.</p> <p>It\u2019s about learning to consistently ask better questions:</p> <ul> <li>What is the responsibility of this piece of code?</li> <li>What assumptions am I making here?</li> <li>Could someone else understand this without me explaining it?</li> <li>Would I be happy maintaining this in six months?</li> </ul> <p>None of those questions are Python-specific \u2014 but they show up in Python, every day.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/10/starting-the-pybites-pdm--from-can-code-to-can-build/#the-first-small-but-important-shift","title":"The first small but important shift","text":"<p>One change I\u2019ve already made as a direct result of starting PDM is this:</p> <p>I\u2019m writing notes as if I\u2019m teaching.</p> <p>Not documentation-after-the-fact, but thinking-through-the-problem-on-paper:</p> <ul> <li>Why did this fail?</li> <li>What did I misunderstand?</li> <li>What\u2019s the underlying mechanism?</li> <li>What\u2019s the rule of thumb I want to remember?</li> </ul> <p>This blog exists largely for that reason.</p> <p>Writing forces me to be precise. Precision exposes gaps. Gaps tell me what to work on next.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/10/starting-the-pybites-pdm--from-can-code-to-can-build/#what-im-hoping-to-get-out-of-pdm","title":"What I\u2019m hoping to get out of PDM","text":"<p>I\u2019m not chasing \u201cclever\u201d code.</p> <p>I want to get better at:</p> <ul> <li>Writing simple code that stays simple</li> <li>Making intent obvious</li> <li>Reducing cognitive load</li> <li>Being deliberate about structure, not accidental</li> <li>Developing habits that scale beyond a single script</li> </ul> <p>In short: becoming someone who builds systems, not just solutions.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/10/starting-the-pybites-pdm--from-can-code-to-can-build/#early-takeaway","title":"Early takeaway","text":"<p>If I had to summarise the early feeling in one sentence:</p> <p>This isn\u2019t about learning more Python \u2014 it\u2019s about learning how to think while writing Python.</p> <p>That feels like time well spent.</p> <p>I\u2019ll keep using this blog to capture what I\u2019m learning, where I\u2019m getting stuck, and what\u2019s starting to click.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/27/setting-up-a-production-grade-python-project-from-scratch/","title":"Setting Up a Production-Grade Python Project (From Scratch)","text":"<p>Recently, I deliberately slowed down and spent time setting up a production-grade Python project from first principles, rather than jumping straight into feature development. The goal wasn\u2019t to \u201cget something working\u201d, but to understand how the tooling fits together and why these practices matter in real teams.</p> <p>This post captures what I focused on and what I learned.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/27/setting-up-a-production-grade-python-project-from-scratch/#why-start-from-scratch","title":"Why start from scratch?","text":"<p>It\u2019s very easy to inherit a project where: - CI already exists - pre-commit hooks are already installed - <code>pyproject.toml</code> is already configured</p> <p>The problem is that you can use these things without really understanding them.</p> <p>I wanted to: - understand when and why checks run - know what lives locally vs in CI - be confident adjusting or introducing standards in the future - remove \u201ccargo-cult\u201d tooling from my workflow</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/27/setting-up-a-production-grade-python-project-from-scratch/#a-single-source-of-truth-pyprojecttoml","title":"A single source of truth: <code>pyproject.toml</code>","text":"<p>I started by treating <code>pyproject.toml</code> as the central contract for the project.</p> <p>Key things I paid attention to: - Separating runtime dependencies from development dependencies - Explicitly configuring tooling rather than relying on defaults - Making sure linting, formatting, typing, and testing all had a clear home</p> <p>This helped reinforce that: - tooling configuration belongs with the code - new contributors should get the same behaviour by default - CI should simply reuse what\u2019s already defined locally</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/27/setting-up-a-production-grade-python-project-from-scratch/#ruff-pytest-and-mypy-clear-responsibilities","title":"Ruff, pytest, and mypy: clear responsibilities","text":"<p>I made sure I was clear on what each tool is responsible for:</p> <ul> <li> <p>Ruff   Linting and formatting \u2014 fast feedback, consistent style, fewer bikeshedding discussions.</p> </li> <li> <p>pytest   Executable specifications. Tests describe what the code should do, not how it does it.</p> </li> <li> <p>mypy   Static type checking as a design aid, not a runtime requirement. Python still runs dynamically, but mypy gives early signals when assumptions don\u2019t line up.</p> </li> </ul> <p>Understanding these roles made the setup feel intentional rather than \u201ctool soup\u201d.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/27/setting-up-a-production-grade-python-project-from-scratch/#pre-commit-hooks-shifting-quality-left","title":"Pre-commit hooks: shifting quality left","text":"<p>One of the most useful things I revisited was pre-commit.</p> <p>What clicked for me this time: - Pre-commit is a gate, not a suggestion - Hooks failing means the commit does not happen - Auto-fixing hooks deliberately fail so you re-stage changes consciously</p> <p>This creates a workflow where: - mistakes are caught before they enter history - CI becomes less noisy - \u201cfix lint\u201d commits disappear</p> <p>Local correctness first, shared correctness later.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/27/setting-up-a-production-grade-python-project-from-scratch/#github-actions-ci-as-an-extension-of-local-checks","title":"GitHub Actions: CI as an extension of local checks","text":"<p>Rather than inventing new rules in CI, I mirrored the local checks:</p> <ul> <li>lint</li> <li>format check</li> <li>type check</li> <li>tests + coverage</li> </ul> <p>The important realisation here was:</p> <p>CI should verify standards, not define them.</p> <p>If something fails in CI but wasn\u2019t enforced locally, that\u2019s a design smell.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/27/setting-up-a-production-grade-python-project-from-scratch/#why-this-mattered-before-writing-more-code","title":"Why this mattered before writing more code","text":"<p>At first glance, this kind of setup can feel like \u201cnot making progress\u201d.</p> <p>In reality: - I now have a repeatable baseline for future projects - I\u2019m confident explaining and justifying these choices to others - adding new code feels safer and more deliberate - I\u2019m better equipped to improve or introduce standards in existing codebases</p> <p>Most importantly, the tooling now supports learning rather than getting in the way of it.</p>","tags":["pybites","pdm"]},{"location":"blog/2026/01/27/setting-up-a-production-grade-python-project-from-scratch/#final-reflection","title":"Final reflection","text":"<p>This was a reminder that good engineering isn\u2019t just about writing code \u2014 it\u2019s about creating an environment where good code is the default outcome.</p> <p>Taking the time to understand the foundations has already paid off, and it\u2019s a pattern I plan to repeat whenever I start something new.</p>","tags":["pybites","pdm"]},{"location":"blog/archive/2026/","title":"2026","text":""},{"location":"blog/category/python/","title":"Python","text":""},{"location":"blog/category/uv/","title":"uv","text":""},{"location":"blog/category/cicd/","title":"ci/cd","text":""},{"location":"blog/category/docker/","title":"Docker","text":""}]}